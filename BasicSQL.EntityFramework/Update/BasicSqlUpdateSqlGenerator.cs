using Microsoft.EntityFrameworkCore.Update;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Metadata;
using System.Text;
using System.Linq;
using System;

namespace BasicSQL.EntityFramework.Update;

/// <summary>
/// BasicSQL implementation of SQL update statement generator.
/// </summary>
public class BasicSqlUpdateSqlGenerator : UpdateSqlGenerator
{
    /// <summary>
    /// Initializes a new instance of the <see cref="BasicSqlUpdateSqlGenerator"/> class.
    /// </summary>
    /// <param name="dependencies">The dependencies.</param>
    public BasicSqlUpdateSqlGenerator(UpdateSqlGeneratorDependencies dependencies)
        : base(dependencies)
    {
    }

    /// <summary>
    /// Generates SQL for an INSERT statement.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="command">The modification command.</param>
    /// <param name="commandPosition">The command position.</param>
    /// <returns>The result set mapping.</returns>
    public override ResultSetMapping AppendInsertOperation(
        StringBuilder commandText,
        IReadOnlyModificationCommand command,
        int commandPosition)
    {
        var table = StoreObjectIdentifier.Table(command.TableName, command.Schema);
        var operations = command.ColumnModifications;

        // Get all write operations and include them in the SQL
        // This ensures that all required column values are available for row key creation
        var writeOperations = operations.Where(o => o.IsWrite);

        commandText.Append("INSERT INTO ");
        SqlGenerationHelper.DelimitIdentifier(commandText, command.TableName, command.Schema);

        commandText.Append(" (");
        AppendColumnList(commandText, writeOperations);
        commandText.Append(") VALUES (");
        AppendValuesHeader(commandText, writeOperations);
        commandText.Append(")");

        // Check if there are any auto-generated columns that would need values returned
        var hasAutoGeneratedColumns = operations.Any(o => 
            o.Property?.ValueGenerated == ValueGenerated.OnAdd &&
            (o.Property.ClrType == typeof(int) || o.Property.ClrType == typeof(long)));

        // For now, return NoResults since BasicSQL doesn't support returning generated values
        // In a complete implementation, you might want to append a SELECT statement to get generated IDs
        return ResultSetMapping.NoResults;
    }

    /// <summary>
    /// Generates SQL for an UPDATE statement.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="command">The modification command.</param>
    /// <param name="commandPosition">The command position.</param>
    /// <returns>The result set mapping.</returns>
    public override ResultSetMapping AppendUpdateOperation(
        StringBuilder commandText,
        IReadOnlyModificationCommand command,
        int commandPosition)
    {
        var table = StoreObjectIdentifier.Table(command.TableName, command.Schema);
        var writeOperations = command.ColumnModifications.Where(o => o.IsWrite);
        var conditionOperations = command.ColumnModifications.Where(o => o.IsCondition);

        commandText.Append("UPDATE ");
        SqlGenerationHelper.DelimitIdentifier(commandText, command.TableName, command.Schema);
        commandText.Append(" SET ");

        AppendUpdateColumnValueList(commandText, writeOperations);

        AppendWhereClause(commandText, conditionOperations);

        return ResultSetMapping.NoResults;
    }

    /// <summary>
    /// Generates SQL for a DELETE statement.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="command">The modification command.</param>
    /// <param name="commandPosition">The command position.</param>
    /// <returns>The result set mapping.</returns>
    public override ResultSetMapping AppendDeleteOperation(
        StringBuilder commandText,
        IReadOnlyModificationCommand command,
        int commandPosition)
    {
        var table = StoreObjectIdentifier.Table(command.TableName, command.Schema);
        var conditionOperations = command.ColumnModifications.Where(o => o.IsCondition);

        commandText.Append("DELETE FROM ");
        SqlGenerationHelper.DelimitIdentifier(commandText, command.TableName, command.Schema);

        AppendWhereClause(commandText, conditionOperations);

        return ResultSetMapping.NoResults;
    }

    /// <summary>
    /// Appends the column list for INSERT statements.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="operations">The column operations.</param>
    protected virtual void AppendColumnList(StringBuilder commandText, IEnumerable<IColumnModification> operations)
    {
        var first = true;
        foreach (var operation in operations)
        {
            if (first)
                first = false;
            else
                commandText.Append(", ");

            SqlGenerationHelper.DelimitIdentifier(commandText, operation.ColumnName);
        }
    }

    /// <summary>
    /// Appends the VALUES clause for INSERT statements.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="operations">The column operations.</param>
    protected virtual void AppendValuesHeader(StringBuilder commandText, IEnumerable<IColumnModification> operations)
    {
        var first = true;
        foreach (var operation in operations)
        {
            if (first)
                first = false;
            else
                commandText.Append(", ");

            if (operation.UseCurrentValueParameter)
            {
                SqlGenerationHelper.GenerateParameterName(commandText, operation.ParameterName!);
            }
            else if (operation.UseOriginalValueParameter)
            {
                SqlGenerationHelper.GenerateParameterName(commandText, operation.OriginalParameterName!);
            }
            else
            {
                commandText.Append(operation.Value ?? "NULL");
            }
        }
    }

    /// <summary>
    /// Appends the SET clause for UPDATE statements.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="operations">The column operations.</param>
    protected virtual void AppendUpdateColumnValueList(StringBuilder commandText, IEnumerable<IColumnModification> operations)
    {
        var first = true;
        foreach (var operation in operations)
        {
            if (first)
                first = false;
            else
                commandText.Append(", ");

            SqlGenerationHelper.DelimitIdentifier(commandText, operation.ColumnName);
            commandText.Append(" = ");

            if (operation.UseCurrentValueParameter)
            {
                SqlGenerationHelper.GenerateParameterName(commandText, operation.ParameterName!);
            }
            else if (operation.UseOriginalValueParameter)
            {
                SqlGenerationHelper.GenerateParameterName(commandText, operation.OriginalParameterName!);
            }
            else
            {
                commandText.Append(operation.Value ?? "NULL");
            }
        }
    }

    /// <summary>
    /// Appends the WHERE clause for UPDATE and DELETE statements.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="operations">The column operations.</param>
    protected virtual void AppendWhereClause(StringBuilder commandText, IEnumerable<IColumnModification> operations)
    {
        if (operations.Any())
        {
            commandText.Append(" WHERE ");
            AppendWhereCondition(commandText, operations, true);
        }
    }

    /// <summary>
    /// Appends WHERE conditions.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="operations">The column operations.</param>
    /// <param name="useOriginalValue">Whether to use original values.</param>
    protected virtual void AppendWhereCondition(
        StringBuilder commandText,
        IEnumerable<IColumnModification> operations,
        bool useOriginalValue)
    {
        var first = true;
        foreach (var operation in operations)
        {
            if (first)
                first = false;
            else
                commandText.Append(" AND ");

            SqlGenerationHelper.DelimitIdentifier(commandText, operation.ColumnName);

            if (useOriginalValue && operation.UseOriginalValueParameter)
            {
                commandText.Append(" = ");
                SqlGenerationHelper.GenerateParameterName(commandText, operation.OriginalParameterName!);
            }
            else if (!useOriginalValue && operation.UseCurrentValueParameter)
            {
                commandText.Append(" = ");
                SqlGenerationHelper.GenerateParameterName(commandText, operation.ParameterName!);
            }
            else
            {
                var value = useOriginalValue ? operation.OriginalValue : operation.Value;
                if (value == null)
                {
                    commandText.Append(" IS NULL");
                }
                else
                {
                    commandText.Append(" = ");
                    commandText.Append(value);
                }
            }
        }
    }

    /// <summary>
    /// Checks if a column modification represents an auto-generated column.
    /// </summary>
    /// <param name="columnModification">The column modification.</param>
    /// <returns>True if the column is auto-generated, false otherwise.</returns>
    private bool IsAutoGenerated(IColumnModification columnModification)
    {
        return columnModification.Property?.ValueGenerated == ValueGenerated.OnAdd &&
               (columnModification.Property.ClrType == typeof(int) || 
                columnModification.Property.ClrType == typeof(long));
    }

    /// <summary>
    /// Checks if a column modification represents an auto-generated column with a temporary value.
    /// </summary>
    /// <param name="columnModification">The column modification.</param>
    /// <returns>True if the column is auto-generated with a temporary value, false otherwise.</returns>
    private bool IsAutoGeneratedWithTemporaryValue(IColumnModification columnModification)
    {
        if (!IsAutoGenerated(columnModification))
            return false;

        // Check if the value is negative (indicating a temporary value)
        if (columnModification.Value is int intValue && intValue < 0)
            return true;
            
        if (columnModification.Value is long longValue && longValue < 0)
            return true;

        return false;
    }
}
