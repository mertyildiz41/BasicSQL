using Microsoft.EntityFrameworkCore.Update;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.Extensions.Logging;
using System.Text;
using System.Linq;
using System;

namespace BasicSQL.EntityFramework.Update;

/// <summary>
/// BasicSQL implementation of SQL update statement generator.
/// </summary>
public class BasicSqlUpdateSqlGenerator : UpdateSqlGenerator
{
    /// <summary>
    /// Initializes a new instance of the <see cref="BasicSqlUpdateSqlGenerator"/> class.
    /// </summary>
    /// <param name="dependencies">The dependencies.</param>
    public BasicSqlUpdateSqlGenerator(UpdateSqlGeneratorDependencies dependencies)
        : base(dependencies)
    {
    }

    /// <summary>
    /// Generates SQL for an INSERT statement.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="command">The modification command.</param>
    /// <param name="commandPosition">The command position.</param>
    /// <returns>The result set mapping.</returns>
    public override ResultSetMapping AppendInsertOperation(
        StringBuilder commandText,
        IReadOnlyModificationCommand command,
        int commandPosition)
    {
        var operations = command.ColumnModifications;
        
        // Filter out columns that are database-generated.
        var writeOperations = operations.Where(o => o.IsWrite && !IsAutoGenerated(o)).ToList();

        commandText.Append("INSERT INTO ");
        SqlGenerationHelper.DelimitIdentifier(commandText, command.TableName, command.Schema);

        if (writeOperations.Any())
        {
            commandText.Append(" (");
            AppendColumnList(commandText, writeOperations);
            commandText.Append(") VALUES (");
            AppendValues(commandText, writeOperations);
            commandText.Append(")");
        }
        else
        {
            commandText.Append(" DEFAULT VALUES");
        }

        commandText.Append(';');
        return ResultSetMapping.NoResults;
    }

    private void AppendValues(StringBuilder commandText, IReadOnlyList<IColumnModification> operations)
    {
        if (operations.Any())
        {
            for (var i = 0; i < operations.Count; i++)
            {
                if (i > 0)
                {
                    commandText.Append(", ");
                }
                var modification = operations[i];
                SqlGenerationHelper.GenerateParameterName(commandText, modification.ParameterName);
            }
        }
    }

    /// <summary>
    /// Generates SQL for an UPDATE statement.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="command">The modification command.</param>
    /// <param name="commandPosition">The command position.</param>
    /// <returns>The result set mapping.</returns>
    public override ResultSetMapping AppendUpdateOperation(
        StringBuilder commandText,
        IReadOnlyModificationCommand command,
        int commandPosition)
    {
        var table = StoreObjectIdentifier.Table(command.TableName, command.Schema);
        var writeOperations = command.ColumnModifications.Where(o => o.IsWrite);
        var conditionOperations = command.ColumnModifications.Where(o => o.IsCondition);

        commandText.Append("UPDATE ");
        SqlGenerationHelper.DelimitIdentifier(commandText, command.TableName, command.Schema);
        commandText.Append(" SET ");

        AppendUpdateColumnValueList(commandText, writeOperations);

        AppendWhereClause(commandText, conditionOperations);

        return ResultSetMapping.NoResults;
    }

    /// <summary>
    /// Generates SQL for a DELETE statement.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="command">The modification command.</param>
    /// <param name="commandPosition">The command position.</param>
    /// <returns>The result set mapping.</returns>
    public override ResultSetMapping AppendDeleteOperation(
        StringBuilder commandText,
        IReadOnlyModificationCommand command,
        int commandPosition)
    {
        var table = StoreObjectIdentifier.Table(command.TableName, command.Schema);
        var conditionOperations = command.ColumnModifications.Where(o => o.IsCondition);

        commandText.Append("DELETE FROM ");
        SqlGenerationHelper.DelimitIdentifier(commandText, command.TableName, command.Schema);

        AppendWhereClause(commandText, conditionOperations);

        return ResultSetMapping.NoResults;
    }

    /// <summary>
    /// Appends the column list for INSERT statements.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="operations">The column operations.</param>
    protected virtual void AppendColumnList(StringBuilder commandText, IEnumerable<IColumnModification> operations)
    {
        var first = true;
        foreach (var operation in operations)
        {
            if (first)
                first = false;
            else
                commandText.Append(", ");

            SqlGenerationHelper.DelimitIdentifier(commandText, operation.ColumnName);
        }
    }

    /// <summary>
    /// Appends the VALUES clause for INSERT statements.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="operations">The column operations.</param>
    protected virtual void AppendValuesHeader(StringBuilder commandText, IEnumerable<IColumnModification> operations)
    {
        var first = true;
        foreach (var operation in operations)
        {
            if (IsAutoGenerated(operation))
                continue;

            if (first)
                first = false;
            else
                commandText.Append(", ");

            if (operation.UseCurrentValueParameter)
            {
                SqlGenerationHelper.GenerateParameterName(commandText, operation.ParameterName!);
            }
            else if (operation.UseOriginalValueParameter)
            {
                SqlGenerationHelper.GenerateParameterName(commandText, operation.OriginalParameterName!);
            }
            else
            {
                commandText.Append(SqlGenerationHelper.GenerateLiteral(operation.Value));
            }
        }
    }

    /// <summary>
    /// Appends the SET clause for UPDATE statements.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="operations">The column operations.</param>
    protected virtual void AppendUpdateColumnValueList(StringBuilder commandText, IEnumerable<IColumnModification> operations)
    {
        var first = true;
        foreach (var operation in operations)
        {
            if (first)
                first = false;
            else
                commandText.Append(", ");

            SqlGenerationHelper.DelimitIdentifier(commandText, operation.ColumnName);
            commandText.Append(" = ");

            if (operation.UseCurrentValueParameter)
            {
                SqlGenerationHelper.GenerateParameterName(commandText, operation.ParameterName!);
            }
            else if (operation.UseOriginalValueParameter)
            {
                SqlGenerationHelper.GenerateParameterName(commandText, operation.OriginalParameterName!);
            }
            else
            {
                commandText.Append(SqlGenerationHelper.GenerateLiteral(operation.Value));
            }
        }
    }

    /// <summary>
    /// Appends the WHERE clause for UPDATE and DELETE statements.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="operations">The column operations.</param>
    protected virtual void AppendWhereClause(StringBuilder commandText, IEnumerable<IColumnModification> operations)
    {
        if (operations.Any())
        {
            commandText.Append(" WHERE ");
            AppendWhereCondition(commandText, operations, true);
        }
    }

    /// <summary>
    /// Appends WHERE conditions.
    /// </summary>
    /// <param name="commandText">The command text builder.</param>
    /// <param name="operations">The column operations.</param>
    /// <param name="useOriginalValue">Whether to use original values.</param>
    protected virtual void AppendWhereCondition(
        StringBuilder commandText,
        IEnumerable<IColumnModification> operations,
        bool useOriginalValue)
    {
        var first = true;
        foreach (var operation in operations)
        {
            if (first)
                first = false;
            else
                commandText.Append(" AND ");

            SqlGenerationHelper.DelimitIdentifier(commandText, operation.ColumnName);

            if (useOriginalValue && operation.UseOriginalValueParameter)
            {
                commandText.Append(" = ");
                SqlGenerationHelper.GenerateParameterName(commandText, operation.OriginalParameterName!);
            }
            else if (!useOriginalValue && operation.UseCurrentValueParameter)
            {
                commandText.Append(" = ");
                SqlGenerationHelper.GenerateParameterName(commandText, operation.ParameterName!);
            }
            else
            {
                var value = useOriginalValue ? operation.OriginalValue : operation.Value;
                if (value == null)
                {
                    commandText.Append(" IS NULL");
                }
                else
                {
                    commandText.Append(" = ");
                    commandText.Append(SqlGenerationHelper.GenerateLiteral(value));
                }
            }
        }
    }

    /// <summary>
    /// Checks if a column modification represents an auto-generated column.
    /// </summary>
    /// <param name="columnModification">The column modification.</param>
    /// <returns>True if the column is auto-generated, false otherwise.</returns>
    private bool IsAutoGenerated(IColumnModification columnModification)
    {
        var property = columnModification.Property;
        return property != null && property.ValueGenerated == ValueGenerated.OnAdd && property.IsPrimaryKey();
    }
}
